#!/usr/bin/env python3
"""
SQLite to Supabase PostgreSQL Migration Script
Generated by ruv-swarm migration agents

This script handles the data migration from SQLite to Supabase PostgreSQL,
including data type conversions, batch processing, and validation.
"""

import os
import sys
import sqlite3
import asyncio
import json
import logging
from datetime import datetime
from decimal import Decimal
from typing import Dict, List, Any, Optional, Tuple
import argparse
from tqdm import tqdm
import psycopg2
from psycopg2.extras import Json, execute_batch
from psycopg2 import sql
import hashlib
import uuid

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('migration.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

class SQLiteToSupabaseMigrator:
    """Handles migration from SQLite to Supabase PostgreSQL"""
    
    def __init__(self, sqlite_path: str, pg_connection_string: str, batch_size: int = 1000):
        self.sqlite_path = sqlite_path
        self.pg_connection_string = pg_connection_string
        self.batch_size = batch_size
        self.sqlite_conn = None
        self.pg_conn = None
        self.migration_stats = {
            'tables_migrated': 0,
            'total_records': 0,
            'errors': [],
            'warnings': []
        }
        
    def connect(self):
        """Establish database connections"""
        try:
            # Connect to SQLite
            self.sqlite_conn = sqlite3.connect(self.sqlite_path)
            self.sqlite_conn.row_factory = sqlite3.Row
            logger.info(f"Connected to SQLite database: {self.sqlite_path}")
            
            # Connect to PostgreSQL
            self.pg_conn = psycopg2.connect(self.pg_connection_string)
            self.pg_conn.autocommit = False
            logger.info("Connected to Supabase PostgreSQL")
            
        except Exception as e:
            logger.error(f"Connection error: {e}")
            raise
            
    def disconnect(self):
        """Close database connections"""
        if self.sqlite_conn:
            self.sqlite_conn.close()
        if self.pg_conn:
            self.pg_conn.close()
            
    def backup_database(self):
        """Create a backup of the SQLite database"""
        backup_path = f"{self.sqlite_path}.backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        try:
            import shutil
            shutil.copy2(self.sqlite_path, backup_path)
            logger.info(f"Database backed up to: {backup_path}")
            return backup_path
        except Exception as e:
            logger.error(f"Backup failed: {e}")
            raise
            
    def get_table_order(self) -> List[str]:
        """Get tables in dependency order for migration"""
        return [
            'users',
            'categories',
            'configurations',
            'import_rules',
            'jobs',
            'etilize_import_batches',
            'products',
            'sync_queue',
            'icons',
            'sync_history',
            'system_logs',
            'shopify_syncs',
            'product_images',
            'product_metafields',
            'etilize_staging_products',
            'product_sources',
            'product_change_logs'
        ]
        
    def convert_sqlite_value(self, value: Any, target_type: str) -> Any:
        """Convert SQLite value to PostgreSQL compatible format"""
        if value is None:
            return None
            
        # Handle JSON/JSONB conversion
        if target_type in ['json', 'jsonb']:
            if isinstance(value, str):
                try:
                    return Json(json.loads(value))
                except:
                    return Json({})
            return Json(value)
            
        # Handle boolean conversion
        if target_type == 'boolean':
            if isinstance(value, int):
                return bool(value)
            return value
            
        # Handle UUID conversion
        if target_type == 'uuid':
            if isinstance(value, str) and len(value) == 36:
                return value
            return str(uuid.uuid4())
            
        # Handle datetime conversion
        if target_type in ['timestamp', 'timestamptz']:
            if isinstance(value, str):
                try:
                    return datetime.fromisoformat(value.replace('Z', '+00:00'))
                except:
                    return None
            return value
            
        # Handle decimal conversion
        if target_type == 'decimal':
            if value is not None:
                return Decimal(str(value))
            return None
            
        # Handle enum conversions
        enum_mappings = {
            'job_status': ['pending', 'running', 'completed', 'failed', 'cancelled', 'paused'],
            'sync_status': ['pending', 'in_progress', 'completed', 'failed', 'partial', 'cancelled'],
            'queue_status': ['pending', 'processing', 'completed', 'failed', 'cancelled', 'retry'],
            'icon_status': ['pending', 'generating', 'generated', 'failed', 'uploaded'],
            'product_status': ['draft', 'active', 'archived', 'deleted'],
            'log_level': ['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']
        }
        
        for enum_type, valid_values in enum_mappings.items():
            if target_type == enum_type:
                if value in valid_values:
                    return value
                # Map to closest valid value
                return 'pending' if 'pending' in valid_values else valid_values[0]
                
        return value
        
    def get_column_mappings(self, table_name: str) -> Dict[str, Dict[str, Any]]:
        """Get column mappings for data type conversion"""
        mappings = {
            'users': {
                'id': {'type': 'integer', 'skip': False},
                'email': {'type': 'string'},
                'password_hash': {'type': 'string'},
                'first_name': {'type': 'string'},
                'last_name': {'type': 'string'},
                'is_active': {'type': 'boolean'},
                'is_admin': {'type': 'boolean'},
                'last_login': {'type': 'timestamptz'},
                'created_at': {'type': 'timestamptz'},
                'updated_at': {'type': 'timestamptz'},
                'supabase_id': {'type': 'uuid'}
            },
            'categories': {
                'id': {'type': 'integer'},
                'name': {'type': 'string'},
                'slug': {'type': 'string'},
                'description': {'type': 'string'},
                'parent_id': {'type': 'integer'},
                'level': {'type': 'integer'},
                'path': {'type': 'string'},
                'sort_order': {'type': 'integer'},
                'is_active': {'type': 'boolean'},
                'shopify_collection_id': {'type': 'string'},
                'shopify_handle': {'type': 'string'},
                'shopify_synced_at': {'type': 'timestamptz'},
                'meta_data': {'type': 'jsonb'},
                'created_at': {'type': 'timestamptz'},
                'updated_at': {'type': 'timestamptz'}
            },
            'products': {
                'id': {'type': 'integer'},
                'sku': {'type': 'string'},
                'name': {'type': 'string'},
                'description': {'type': 'string'},
                'short_description': {'type': 'string'},
                'price': {'type': 'decimal'},
                'compare_at_price': {'type': 'decimal'},
                'cost_price': {'type': 'decimal'},
                'brand': {'type': 'string'},
                'manufacturer': {'type': 'string'},
                'manufacturer_part_number': {'type': 'string'},
                'upc': {'type': 'string'},
                'weight': {'type': 'decimal'},
                'weight_unit': {'type': 'string'},
                'length': {'type': 'decimal'},
                'width': {'type': 'decimal'},
                'height': {'type': 'decimal'},
                'dimension_unit': {'type': 'string'},
                'inventory_quantity': {'type': 'integer'},
                'track_inventory': {'type': 'boolean'},
                'continue_selling_when_out_of_stock': {'type': 'boolean'},
                'seo_title': {'type': 'string'},
                'seo_description': {'type': 'string'},
                'status': {'type': 'product_status'},
                'is_active': {'type': 'boolean'},
                'category_id': {'type': 'integer'},
                'shopify_product_id': {'type': 'string'},
                'shopify_variant_id': {'type': 'string'},
                'shopify_handle': {'type': 'string'},
                'shopify_synced_at': {'type': 'timestamptz'},
                'shopify_sync_status': {'type': 'string'},
                'shopify_id': {'type': 'string'},
                'shopify_status': {'type': 'string'},
                'last_synced': {'type': 'timestamptz'},
                'title': {'type': 'string'},
                'featured_image_url': {'type': 'string'},
                'additional_images': {'type': 'jsonb'},
                'metafields': {'type': 'jsonb'},
                'custom_attributes': {'type': 'jsonb'},
                'etilize_id': {'type': 'string'},
                'primary_source': {'type': 'string'},
                'source_priority': {'type': 'integer'},
                'data_sources': {'type': 'jsonb'},
                'import_batch_id': {'type': 'integer'},
                'last_imported': {'type': 'timestamptz'},
                'import_errors': {'type': 'jsonb'},
                'has_conflicts': {'type': 'boolean'},
                'conflict_resolution': {'type': 'jsonb'},
                'manual_overrides': {'type': 'jsonb'},
                'etilize_data': {'type': 'jsonb'},
                'computed_fields': {'type': 'jsonb'},
                'data_quality_score': {'type': 'decimal'},
                'completeness_score': {'type': 'decimal'},
                'created_at': {'type': 'timestamptz'},
                'updated_at': {'type': 'timestamptz'}
            },
            'sync_queue': {
                'id': {'type': 'integer'},
                'queue_uuid': {'type': 'uuid'},
                'item_type': {'type': 'string'},
                'item_id': {'type': 'integer'},
                'target_system': {'type': 'string'},
                'operation_type': {'type': 'string'},
                'operation_data': {'type': 'jsonb'},
                'priority': {'type': 'integer'},
                'scheduled_at': {'type': 'timestamptz'},
                'status': {'type': 'queue_status'},
                'attempts': {'type': 'integer'},
                'max_attempts': {'type': 'integer'},
                'started_at': {'type': 'timestamptz'},
                'completed_at': {'type': 'timestamptz'},
                'duration': {'type': 'integer'},
                'last_error': {'type': 'string'},
                'error_details': {'type': 'jsonb'},
                'depends_on': {'type': 'jsonb'},
                'blocks': {'type': 'jsonb'},
                'created_at': {'type': 'timestamptz'},
                'updated_at': {'type': 'timestamptz'}
            },
            'icons': {
                'id': {'type': 'integer'},
                'category_id': {'type': 'integer'},
                'filename': {'type': 'string'},
                'file_path': {'type': 'string'},
                'file_size': {'type': 'integer'},
                'file_hash': {'type': 'string'},
                'width': {'type': 'integer'},
                'height': {'type': 'integer'},
                'format': {'type': 'string'},
                'prompt': {'type': 'string'},
                'style': {'type': 'string'},
                'color': {'type': 'string'},
                'background': {'type': 'string'},
                'model': {'type': 'string'},
                'status': {'type': 'icon_status'},
                'is_active': {'type': 'boolean'},
                'shopify_image_id': {'type': 'string'},
                'shopify_image_url': {'type': 'string'},
                'shopify_synced_at': {'type': 'timestamptz'},
                'shopify_sync_status': {'type': 'string'},
                'generation_time': {'type': 'decimal'},
                'generation_cost': {'type': 'decimal'},
                'generation_batch_id': {'type': 'string'},
                'created_by': {'type': 'integer'},
                'meta_data': {'type': 'jsonb'},
                'created_at': {'type': 'timestamptz'},
                'updated_at': {'type': 'timestamptz'}
            },
            'jobs': {
                'id': {'type': 'integer'},
                'job_uuid': {'type': 'uuid'},
                'script_name': {'type': 'string'},
                'display_name': {'type': 'string'},
                'description': {'type': 'string'},
                'status': {'type': 'job_status'},
                'progress': {'type': 'integer'},
                'current_stage': {'type': 'string'},
                'created_at': {'type': 'timestamptz'},
                'started_at': {'type': 'timestamptz'},
                'completed_at': {'type': 'timestamptz'},
                'estimated_duration': {'type': 'integer'},
                'actual_duration': {'type': 'integer'},
                'parameters': {'type': 'jsonb'},
                'options': {'type': 'jsonb'},
                'result': {'type': 'jsonb'},
                'error_message': {'type': 'string'},
                'output_log': {'type': 'string'},
                'log_file_path': {'type': 'string'},
                'user_id': {'type': 'integer'},
                'priority': {'type': 'integer'},
                'retry_count': {'type': 'integer'},
                'max_retries': {'type': 'integer'},
                'meta_data': {'type': 'jsonb'}
            },
            'sync_history': {
                'id': {'type': 'integer'},
                'sync_type': {'type': 'string'},
                'sync_source': {'type': 'string'},
                'sync_target': {'type': 'string'},
                'status': {'type': 'sync_status'},
                'started_at': {'type': 'timestamptz'},
                'completed_at': {'type': 'timestamptz'},
                'duration': {'type': 'integer'},
                'total_items': {'type': 'integer'},
                'items_processed': {'type': 'integer'},
                'items_successful': {'type': 'integer'},
                'items_failed': {'type': 'integer'},
                'items_skipped': {'type': 'integer'},
                'products_synced': {'type': 'integer'},
                'categories_synced': {'type': 'integer'},
                'icons_synced': {'type': 'integer'},
                'message': {'type': 'string'},
                'error_message': {'type': 'string'},
                'warnings': {'type': 'jsonb'},
                'errors': {'type': 'jsonb'},
                'input_files': {'type': 'jsonb'},
                'output_files': {'type': 'jsonb'},
                'log_file_path': {'type': 'string'},
                'user_id': {'type': 'integer'},
                'job_id': {'type': 'integer'},
                'meta_data': {'type': 'jsonb'}
            },
            'system_logs': {
                'id': {'type': 'integer'},
                'level': {'type': 'log_level'},
                'message': {'type': 'string'},
                'logger_name': {'type': 'string'},
                'module': {'type': 'string'},
                'function': {'type': 'string'},
                'line_number': {'type': 'integer'},
                'user_id': {'type': 'integer'},
                'job_id': {'type': 'integer'},
                'session_id': {'type': 'string'},
                'request_id': {'type': 'string'},
                'extra_data': {'type': 'jsonb'},
                'stack_trace': {'type': 'string'},
                'created_at': {'type': 'timestamptz'}
            }
        }
        
        # Add remaining table mappings
        remaining_tables = {
            'configurations': {
                'id': {'type': 'integer'},
                'key': {'type': 'string'},
                'value': {'type': 'string'},
                'data_type': {'type': 'string'},
                'description': {'type': 'string'},
                'category': {'type': 'string'},
                'is_required': {'type': 'boolean'},
                'is_encrypted': {'type': 'boolean'},
                'validation_regex': {'type': 'string'},
                'created_at': {'type': 'timestamptz'},
                'updated_at': {'type': 'timestamptz'}
            },
            'import_rules': {
                'id': {'type': 'integer'},
                'rule_name': {'type': 'string'},
                'rule_type': {'type': 'string'},
                'rule_category': {'type': 'string'},
                'conditions': {'type': 'jsonb'},
                'actions': {'type': 'jsonb'},
                'description': {'type': 'string'},
                'priority': {'type': 'integer'},
                'is_active': {'type': 'boolean'},
                'execution_count': {'type': 'integer'},
                'success_count': {'type': 'integer'},
                'failure_count': {'type': 'integer'},
                'last_executed': {'type': 'timestamptz'},
                'created_by': {'type': 'integer'},
                'created_at': {'type': 'timestamptz'},
                'updated_at': {'type': 'timestamptz'}
            },
            'etilize_import_batches': {
                'id': {'type': 'integer'},
                'batch_uuid': {'type': 'uuid'},
                'import_type': {'type': 'string'},
                'source_file_path': {'type': 'string'},
                'source_file_hash': {'type': 'string'},
                'source_file_size': {'type': 'integer'},
                'source_file_modified': {'type': 'timestamptz'},
                'status': {'type': 'sync_status'},
                'stage': {'type': 'string'},
                'progress': {'type': 'integer'},
                'started_at': {'type': 'timestamptz'},
                'completed_at': {'type': 'timestamptz'},
                'duration': {'type': 'integer'},
                'total_records': {'type': 'integer'},
                'records_processed': {'type': 'integer'},
                'records_imported': {'type': 'integer'},
                'records_updated': {'type': 'integer'},
                'records_failed': {'type': 'integer'},
                'records_skipped': {'type': 'integer'},
                'error_count': {'type': 'integer'},
                'warning_count': {'type': 'integer'},
                'error_details': {'type': 'jsonb'},
                'triggered_by': {'type': 'integer'},
                'job_id': {'type': 'integer'},
                'import_config': {'type': 'jsonb'},
                'meta_data': {'type': 'jsonb'},
                'created_at': {'type': 'timestamptz'}
            },
            'shopify_syncs': {
                'id': {'type': 'integer'},
                'sync_uuid': {'type': 'uuid'},
                'mode': {'type': 'string'},
                'configuration': {'type': 'jsonb'},
                'filters': {'type': 'jsonb'},
                'import_batch_id': {'type': 'integer'},
                'status': {'type': 'sync_status'},
                'stage': {'type': 'string'},
                'progress': {'type': 'integer'},
                'created_at': {'type': 'timestamptz'},
                'started_at': {'type': 'timestamptz'},
                'completed_at': {'type': 'timestamptz'},
                'duration': {'type': 'integer'},
                'total_products': {'type': 'integer'},
                'successful_uploads': {'type': 'integer'},
                'failed_uploads': {'type': 'integer'},
                'skipped_uploads': {'type': 'integer'},
                'duplicates_cleaned': {'type': 'integer'},
                'retry_count': {'type': 'integer'},
                'errors': {'type': 'jsonb'},
                'warnings': {'type': 'jsonb'},
                'triggered_by': {'type': 'integer'}
            },
            'product_images': {
                'id': {'type': 'integer'},
                'product_id': {'type': 'integer'},
                'filename': {'type': 'string'},
                'file_path': {'type': 'string'},
                'url': {'type': 'string'},
                'alt_text': {'type': 'string'},
                'width': {'type': 'integer'},
                'height': {'type': 'integer'},
                'file_size': {'type': 'integer'},
                'format': {'type': 'string'},
                'file_hash': {'type': 'string'},
                'sort_order': {'type': 'integer'},
                'is_featured': {'type': 'boolean'},
                'is_active': {'type': 'boolean'},
                'shopify_image_id': {'type': 'string'},
                'shopify_image_url': {'type': 'string'},
                'shopify_synced_at': {'type': 'timestamptz'},
                'meta_data': {'type': 'jsonb'},
                'created_at': {'type': 'timestamptz'},
                'updated_at': {'type': 'timestamptz'}
            },
            'product_metafields': {
                'id': {'type': 'integer'},
                'product_id': {'type': 'integer'},
                'namespace': {'type': 'string'},
                'key': {'type': 'string'},
                'value': {'type': 'string'},
                'value_type': {'type': 'string'},
                'shopify_metafield_id': {'type': 'string'},
                'shopify_owner_id': {'type': 'string'},
                'shopify_owner_resource': {'type': 'string'},
                'description': {'type': 'string'},
                'is_visible': {'type': 'boolean'},
                'display_order': {'type': 'integer'},
                'created_at': {'type': 'timestamptz'},
                'updated_at': {'type': 'timestamptz'}
            },
            'etilize_staging_products': {
                'id': {'type': 'integer'},
                'batch_id': {'type': 'integer'},
                'etilize_id': {'type': 'string'},
                'raw_data': {'type': 'jsonb'},
                'title': {'type': 'string'},
                'sku': {'type': 'string'},
                'manufacturer_part_number': {'type': 'string'},
                'brand': {'type': 'string'},
                'manufacturer': {'type': 'string'},
                'description': {'type': 'string'},
                'price': {'type': 'decimal'},
                'processing_status': {'type': 'string'},
                'validation_status': {'type': 'string'},
                'mapping_status': {'type': 'string'},
                'validation_errors': {'type': 'jsonb'},
                'validation_warnings': {'type': 'jsonb'},
                'mapped_product_id': {'type': 'integer'},
                'mapping_confidence': {'type': 'decimal'},
                'mapping_method': {'type': 'string'},
                'mapping_details': {'type': 'jsonb'},
                'processed_at': {'type': 'timestamptz'},
                'error_message': {'type': 'string'},
                'created_at': {'type': 'timestamptz'},
                'updated_at': {'type': 'timestamptz'}
            },
            'product_sources': {
                'id': {'type': 'integer'},
                'product_id': {'type': 'integer'},
                'source_type': {'type': 'string'},
                'source_priority': {'type': 'integer'},
                'source_identifier': {'type': 'string'},
                'source_url': {'type': 'string'},
                'source_data': {'type': 'jsonb'},
                'last_updated': {'type': 'timestamptz'},
                'sync_status': {'type': 'string'},
                'last_synced': {'type': 'timestamptz'},
                'sync_errors': {'type': 'jsonb'},
                'created_at': {'type': 'timestamptz'},
                'updated_at': {'type': 'timestamptz'}
            },
            'product_change_logs': {
                'id': {'type': 'integer'},
                'product_id': {'type': 'integer'},
                'change_type': {'type': 'string'},
                'field_name': {'type': 'string'},
                'old_value': {'type': 'string'},
                'new_value': {'type': 'string'},
                'value_type': {'type': 'string'},
                'source_type': {'type': 'string'},
                'source_id': {'type': 'string'},
                'triggered_by': {'type': 'integer'},
                'batch_id': {'type': 'integer'},
                'job_id': {'type': 'integer'},
                'change_reason': {'type': 'string'},
                'confidence_score': {'type': 'decimal'},
                'meta_data': {'type': 'jsonb'},
                'created_at': {'type': 'timestamptz'}
            }
        }
        
        mappings.update(remaining_tables)
        return mappings.get(table_name, {})
        
    def migrate_table(self, table_name: str) -> Tuple[int, List[str]]:
        """Migrate a single table from SQLite to PostgreSQL"""
        logger.info(f"Migrating table: {table_name}")
        errors = []
        record_count = 0
        
        try:
            # Get column mappings
            column_mappings = self.get_column_mappings(table_name)
            if not column_mappings:
                logger.warning(f"No column mappings found for table: {table_name}")
                return 0, [f"No mappings for {table_name}"]
                
            # Get data from SQLite
            cursor = self.sqlite_conn.cursor()
            cursor.execute(f"SELECT * FROM {table_name}")
            columns = [description[0] for description in cursor.description]
            
            # Prepare PostgreSQL insert
            pg_cursor = self.pg_conn.cursor()
            
            # Filter columns that exist in mappings
            valid_columns = [col for col in columns if col in column_mappings]
            if not valid_columns:
                logger.warning(f"No valid columns found for table: {table_name}")
                return 0, [f"No valid columns for {table_name}"]
                
            # Build insert query
            placeholders = ', '.join(['%s'] * len(valid_columns))
            column_names = ', '.join([f'"{col}"' for col in valid_columns])
            insert_query = f"INSERT INTO {table_name} ({column_names}) VALUES ({placeholders})"
            
            # Process in batches
            batch = []
            rows = cursor.fetchall()
            total_rows = len(rows)
            
            with tqdm(total=total_rows, desc=f"Migrating {table_name}") as pbar:
                for row in rows:
                    # Convert row data
                    converted_row = []
                    skip_row = False
                    
                    for col in valid_columns:
                        mapping = column_mappings[col]
                        value = row[columns.index(col)]
                        
                        try:
                            converted_value = self.convert_sqlite_value(value, mapping['type'])
                            converted_row.append(converted_value)
                        except Exception as e:
                            errors.append(f"Conversion error in {table_name}.{col}: {e}")
                            skip_row = True
                            break
                            
                    if not skip_row:
                        batch.append(converted_row)
                        record_count += 1
                        
                    # Execute batch
                    if len(batch) >= self.batch_size:
                        try:
                            execute_batch(pg_cursor, insert_query, batch)
                            self.pg_conn.commit()
                            batch = []
                        except Exception as e:
                            errors.append(f"Batch insert error: {e}")
                            self.pg_conn.rollback()
                            
                    pbar.update(1)
                    
            # Execute remaining batch
            if batch:
                try:
                    execute_batch(pg_cursor, insert_query, batch)
                    self.pg_conn.commit()
                except Exception as e:
                    errors.append(f"Final batch insert error: {e}")
                    self.pg_conn.rollback()
                    
            # Update sequences
            if table_name not in ['product_images', 'product_metafields', 'etilize_staging_products', 
                                  'product_sources', 'product_change_logs']:
                try:
                    pg_cursor.execute(f"""
                        SELECT setval(pg_get_serial_sequence('{table_name}', 'id'),
                                     COALESCE((SELECT MAX(id) FROM {table_name}), 1));
                    """)
                    self.pg_conn.commit()
                except Exception as e:
                    logger.warning(f"Could not update sequence for {table_name}: {e}")
                    
            logger.info(f"Migrated {record_count} records from {table_name}")
            
        except Exception as e:
            error_msg = f"Error migrating table {table_name}: {e}"
            logger.error(error_msg)
            errors.append(error_msg)
            self.pg_conn.rollback()
            
        return record_count, errors
        
    def validate_migration(self) -> Dict[str, Any]:
        """Validate the migration by comparing record counts"""
        logger.info("Validating migration...")
        validation_results = {}
        
        for table_name in self.get_table_order():
            try:
                # Get SQLite count
                sqlite_cursor = self.sqlite_conn.cursor()
                sqlite_cursor.execute(f"SELECT COUNT(*) FROM {table_name}")
                sqlite_count = sqlite_cursor.fetchone()[0]
                
                # Get PostgreSQL count
                pg_cursor = self.pg_conn.cursor()
                pg_cursor.execute(f"SELECT COUNT(*) FROM {table_name}")
                pg_count = pg_cursor.fetchone()[0]
                
                validation_results[table_name] = {
                    'sqlite_count': sqlite_count,
                    'postgresql_count': pg_count,
                    'match': sqlite_count == pg_count,
                    'difference': abs(sqlite_count - pg_count)
                }
                
            except Exception as e:
                validation_results[table_name] = {
                    'error': str(e)
                }
                
        return validation_results
        
    def run_migration(self):
        """Run the complete migration process"""
        logger.info("Starting SQLite to Supabase migration...")
        
        try:
            # Connect to databases
            self.connect()
            
            # Create backup
            self.backup_database()
            
            # Migrate tables in dependency order
            for table_name in self.get_table_order():
                record_count, errors = self.migrate_table(table_name)
                self.migration_stats['tables_migrated'] += 1
                self.migration_stats['total_records'] += record_count
                self.migration_stats['errors'].extend(errors)
                
            # Validate migration
            validation_results = self.validate_migration()
            self.migration_stats['validation'] = validation_results
            
            # Generate report
            self.generate_report()
            
        except Exception as e:
            logger.error(f"Migration failed: {e}")
            raise
        finally:
            self.disconnect()
            
    def generate_report(self):
        """Generate migration report"""
        report_path = f"migration_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        with open(report_path, 'w') as f:
            json.dump(self.migration_stats, f, indent=2, default=str)
            
        logger.info(f"Migration report saved to: {report_path}")
        
        # Print summary
        print("\n" + "="*50)
        print("MIGRATION SUMMARY")
        print("="*50)
        print(f"Tables migrated: {self.migration_stats['tables_migrated']}")
        print(f"Total records: {self.migration_stats['total_records']}")
        print(f"Errors: {len(self.migration_stats['errors'])}")
        
        if 'validation' in self.migration_stats:
            print("\nVALIDATION RESULTS:")
            for table, result in self.migration_stats['validation'].items():
                if 'error' in result:
                    print(f"  {table}: ERROR - {result['error']}")
                elif result['match']:
                    print(f"  {table}: OK ({result['postgresql_count']} records)")
                else:
                    print(f"  {table}: MISMATCH - SQLite: {result['sqlite_count']}, PostgreSQL: {result['postgresql_count']}")

def main():
    parser = argparse.ArgumentParser(description='Migrate SQLite database to Supabase PostgreSQL')
    parser.add_argument('--sqlite-path', default='database.db', help='Path to SQLite database')
    parser.add_argument('--pg-connection', required=True, help='PostgreSQL connection string')
    parser.add_argument('--batch-size', type=int, default=1000, help='Batch size for inserts')
    
    args = parser.parse_args()
    
    migrator = SQLiteToSupabaseMigrator(
        sqlite_path=args.sqlite_path,
        pg_connection_string=args.pg_connection,
        batch_size=args.batch_size
    )
    
    migrator.run_migration()

if __name__ == "__main__":
    main()