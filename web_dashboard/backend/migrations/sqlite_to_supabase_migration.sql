-- SQLite to Supabase PostgreSQL Migration Script
-- Generated by ruv-swarm migration agents
-- Date: 2025-01-07

-- ============================================
-- 1. CREATE SCHEMA AND EXTENSIONS
-- ============================================

-- Enable necessary PostgreSQL extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
CREATE EXTENSION IF NOT EXISTS "citext";

-- Create custom types
CREATE TYPE job_status AS ENUM ('pending', 'running', 'completed', 'failed', 'cancelled', 'paused');
CREATE TYPE sync_status AS ENUM ('pending', 'in_progress', 'completed', 'failed', 'partial', 'cancelled');
CREATE TYPE queue_status AS ENUM ('pending', 'processing', 'completed', 'failed', 'cancelled', 'retry');
CREATE TYPE icon_status AS ENUM ('pending', 'generating', 'generated', 'failed', 'uploaded');
CREATE TYPE product_status AS ENUM ('draft', 'active', 'archived', 'deleted');
CREATE TYPE log_level AS ENUM ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL');

-- ============================================
-- 2. CREATE TABLES
-- ============================================

-- Users table (with Supabase auth integration)
CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    email CITEXT NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    is_active BOOLEAN NOT NULL DEFAULT true,
    is_admin BOOLEAN NOT NULL DEFAULT false,
    last_login TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    supabase_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE
);

-- Categories table
CREATE TABLE IF NOT EXISTS categories (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(255) NOT NULL UNIQUE,
    description TEXT,
    parent_id INTEGER REFERENCES categories(id) ON DELETE CASCADE,
    level INTEGER NOT NULL DEFAULT 0,
    path VARCHAR(500),
    sort_order INTEGER DEFAULT 0,
    is_active BOOLEAN NOT NULL DEFAULT true,
    shopify_collection_id VARCHAR(50),
    shopify_handle VARCHAR(255),
    shopify_synced_at TIMESTAMPTZ,
    meta_data JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Configurations table
CREATE TABLE IF NOT EXISTS configurations (
    id SERIAL PRIMARY KEY,
    key VARCHAR(200) NOT NULL UNIQUE,
    value TEXT,
    data_type VARCHAR(20) DEFAULT 'string',
    description TEXT,
    category VARCHAR(100),
    is_required BOOLEAN DEFAULT false,
    is_encrypted BOOLEAN DEFAULT false,
    validation_regex VARCHAR(500),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Sync queue table
CREATE TABLE IF NOT EXISTS sync_queue (
    id SERIAL PRIMARY KEY,
    queue_uuid UUID NOT NULL DEFAULT uuid_generate_v4() UNIQUE,
    item_type VARCHAR(50) NOT NULL,
    item_id INTEGER NOT NULL,
    target_system VARCHAR(50) NOT NULL,
    operation_type VARCHAR(50) NOT NULL,
    operation_data JSONB,
    priority INTEGER DEFAULT 0,
    scheduled_at TIMESTAMPTZ,
    status queue_status DEFAULT 'pending',
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    duration INTEGER,
    last_error TEXT,
    error_details JSONB,
    depends_on JSONB,
    blocks JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Icons table
CREATE TABLE IF NOT EXISTS icons (
    id SERIAL PRIMARY KEY,
    category_id INTEGER NOT NULL REFERENCES categories(id) ON DELETE CASCADE,
    filename VARCHAR(255) NOT NULL,
    file_path VARCHAR(1000) NOT NULL,
    file_size INTEGER,
    file_hash VARCHAR(64),
    width INTEGER,
    height INTEGER,
    format VARCHAR(10),
    prompt TEXT,
    style VARCHAR(50),
    color VARCHAR(20),
    background VARCHAR(20),
    model VARCHAR(50),
    status icon_status NOT NULL DEFAULT 'pending',
    is_active BOOLEAN NOT NULL DEFAULT true,
    shopify_image_id VARCHAR(50),
    shopify_image_url VARCHAR(1000),
    shopify_synced_at TIMESTAMPTZ,
    shopify_sync_status VARCHAR(20),
    generation_time FLOAT,
    generation_cost FLOAT,
    generation_batch_id VARCHAR(50),
    created_by INTEGER NOT NULL REFERENCES users(id),
    meta_data JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Jobs table
CREATE TABLE IF NOT EXISTS jobs (
    id SERIAL PRIMARY KEY,
    job_uuid UUID NOT NULL DEFAULT uuid_generate_v4() UNIQUE,
    script_name VARCHAR(200) NOT NULL,
    display_name VARCHAR(255),
    description TEXT,
    status job_status NOT NULL DEFAULT 'pending',
    progress INTEGER DEFAULT 0 CHECK (progress >= 0 AND progress <= 100),
    current_stage VARCHAR(255),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    estimated_duration INTEGER,
    actual_duration INTEGER,
    parameters JSONB,
    options JSONB,
    result JSONB,
    error_message TEXT,
    output_log TEXT,
    log_file_path VARCHAR(1000),
    user_id INTEGER NOT NULL REFERENCES users(id),
    priority INTEGER DEFAULT 0,
    retry_count INTEGER DEFAULT 0,
    max_retries INTEGER DEFAULT 3,
    meta_data JSONB
);

-- Import rules table
CREATE TABLE IF NOT EXISTS import_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(200) NOT NULL,
    rule_type VARCHAR(50) NOT NULL,
    rule_category VARCHAR(100),
    conditions JSONB NOT NULL,
    actions JSONB NOT NULL,
    description TEXT,
    priority INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT true,
    execution_count INTEGER DEFAULT 0,
    success_count INTEGER DEFAULT 0,
    failure_count INTEGER DEFAULT 0,
    last_executed TIMESTAMPTZ,
    created_by INTEGER NOT NULL REFERENCES users(id),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Sync history table
CREATE TABLE IF NOT EXISTS sync_history (
    id SERIAL PRIMARY KEY,
    sync_type VARCHAR(50) NOT NULL,
    sync_source VARCHAR(50),
    sync_target VARCHAR(50),
    status sync_status NOT NULL DEFAULT 'pending',
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    duration INTEGER,
    total_items INTEGER DEFAULT 0,
    items_processed INTEGER DEFAULT 0,
    items_successful INTEGER DEFAULT 0,
    items_failed INTEGER DEFAULT 0,
    items_skipped INTEGER DEFAULT 0,
    products_synced INTEGER DEFAULT 0,
    categories_synced INTEGER DEFAULT 0,
    icons_synced INTEGER DEFAULT 0,
    message TEXT,
    error_message TEXT,
    warnings JSONB,
    errors JSONB,
    input_files JSONB,
    output_files JSONB,
    log_file_path VARCHAR(1000),
    user_id INTEGER NOT NULL REFERENCES users(id),
    job_id INTEGER REFERENCES jobs(id),
    meta_data JSONB
);

-- System logs table
CREATE TABLE IF NOT EXISTS system_logs (
    id SERIAL PRIMARY KEY,
    level log_level NOT NULL,
    message TEXT NOT NULL,
    logger_name VARCHAR(200),
    module VARCHAR(200),
    function VARCHAR(200),
    line_number INTEGER,
    user_id INTEGER REFERENCES users(id),
    job_id INTEGER REFERENCES jobs(id),
    session_id VARCHAR(100),
    request_id VARCHAR(100),
    extra_data JSONB,
    stack_trace TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Etilize import batches table
CREATE TABLE IF NOT EXISTS etilize_import_batches (
    id SERIAL PRIMARY KEY,
    batch_uuid UUID NOT NULL DEFAULT uuid_generate_v4() UNIQUE,
    import_type VARCHAR(50) NOT NULL,
    source_file_path VARCHAR(1000) NOT NULL,
    source_file_hash VARCHAR(64) NOT NULL,
    source_file_size INTEGER NOT NULL,
    source_file_modified TIMESTAMPTZ NOT NULL,
    status sync_status NOT NULL DEFAULT 'pending',
    stage VARCHAR(50),
    progress INTEGER DEFAULT 0 CHECK (progress >= 0 AND progress <= 100),
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    duration INTEGER,
    total_records INTEGER DEFAULT 0,
    records_processed INTEGER DEFAULT 0,
    records_imported INTEGER DEFAULT 0,
    records_updated INTEGER DEFAULT 0,
    records_failed INTEGER DEFAULT 0,
    records_skipped INTEGER DEFAULT 0,
    error_count INTEGER DEFAULT 0,
    warning_count INTEGER DEFAULT 0,
    error_details JSONB,
    triggered_by INTEGER NOT NULL REFERENCES users(id),
    job_id INTEGER REFERENCES jobs(id),
    import_config JSONB,
    meta_data JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Products table
CREATE TABLE IF NOT EXISTS products (
    id SERIAL PRIMARY KEY,
    sku VARCHAR(100) NOT NULL UNIQUE,
    name VARCHAR(500) NOT NULL,
    description TEXT,
    short_description TEXT,
    price DECIMAL(10,2) NOT NULL,
    compare_at_price DECIMAL(10,2),
    cost_price DECIMAL(10,2),
    brand VARCHAR(200),
    manufacturer VARCHAR(200),
    manufacturer_part_number VARCHAR(200),
    upc VARCHAR(20),
    weight DECIMAL(10,3),
    weight_unit VARCHAR(10) DEFAULT 'kg',
    length DECIMAL(10,3),
    width DECIMAL(10,3),
    height DECIMAL(10,3),
    dimension_unit VARCHAR(10) DEFAULT 'cm',
    inventory_quantity INTEGER DEFAULT 0,
    track_inventory BOOLEAN DEFAULT true,
    continue_selling_when_out_of_stock BOOLEAN DEFAULT false,
    seo_title VARCHAR(255),
    seo_description TEXT,
    status product_status NOT NULL DEFAULT 'draft',
    is_active BOOLEAN NOT NULL DEFAULT true,
    category_id INTEGER NOT NULL REFERENCES categories(id),
    shopify_product_id VARCHAR(50),
    shopify_variant_id VARCHAR(50),
    shopify_handle VARCHAR(255),
    shopify_synced_at TIMESTAMPTZ,
    shopify_sync_status VARCHAR(20),
    shopify_id VARCHAR(50),
    shopify_status VARCHAR(20),
    last_synced TIMESTAMPTZ,
    title VARCHAR(500),
    featured_image_url VARCHAR(1000),
    additional_images JSONB,
    metafields JSONB,
    custom_attributes JSONB,
    etilize_id VARCHAR(100),
    primary_source VARCHAR(50),
    source_priority INTEGER DEFAULT 0,
    data_sources JSONB,
    import_batch_id INTEGER REFERENCES etilize_import_batches(id),
    last_imported TIMESTAMPTZ,
    import_errors JSONB,
    has_conflicts BOOLEAN DEFAULT false,
    conflict_resolution JSONB,
    manual_overrides JSONB,
    etilize_data JSONB,
    computed_fields JSONB,
    data_quality_score DECIMAL(3,2) CHECK (data_quality_score >= 0 AND data_quality_score <= 1),
    completeness_score DECIMAL(3,2) CHECK (completeness_score >= 0 AND completeness_score <= 1),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Shopify syncs table
CREATE TABLE IF NOT EXISTS shopify_syncs (
    id SERIAL PRIMARY KEY,
    sync_uuid UUID NOT NULL DEFAULT uuid_generate_v4() UNIQUE,
    mode VARCHAR(50) NOT NULL,
    configuration JSONB NOT NULL,
    filters JSONB,
    import_batch_id INTEGER REFERENCES etilize_import_batches(id),
    status sync_status NOT NULL DEFAULT 'pending',
    stage VARCHAR(50),
    progress INTEGER DEFAULT 0 CHECK (progress >= 0 AND progress <= 100),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    duration INTEGER,
    total_products INTEGER DEFAULT 0,
    successful_uploads INTEGER DEFAULT 0,
    failed_uploads INTEGER DEFAULT 0,
    skipped_uploads INTEGER DEFAULT 0,
    duplicates_cleaned INTEGER DEFAULT 0,
    retry_count INTEGER DEFAULT 0,
    errors JSONB,
    warnings JSONB,
    triggered_by INTEGER NOT NULL REFERENCES users(id)
);

-- Product images table
CREATE TABLE IF NOT EXISTS product_images (
    id SERIAL PRIMARY KEY,
    product_id INTEGER NOT NULL REFERENCES products(id) ON DELETE CASCADE,
    filename VARCHAR(255) NOT NULL,
    file_path VARCHAR(1000) NOT NULL,
    url VARCHAR(1000),
    alt_text VARCHAR(255),
    width INTEGER,
    height INTEGER,
    file_size INTEGER,
    format VARCHAR(10),
    file_hash VARCHAR(64),
    sort_order INTEGER DEFAULT 0,
    is_featured BOOLEAN DEFAULT false,
    is_active BOOLEAN DEFAULT true,
    shopify_image_id VARCHAR(50),
    shopify_image_url VARCHAR(1000),
    shopify_synced_at TIMESTAMPTZ,
    meta_data JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT uq_product_image_hash UNIQUE (product_id, file_hash)
);

-- Product metafields table
CREATE TABLE IF NOT EXISTS product_metafields (
    id SERIAL PRIMARY KEY,
    product_id INTEGER NOT NULL REFERENCES products(id) ON DELETE CASCADE,
    namespace VARCHAR(255) NOT NULL,
    key VARCHAR(255) NOT NULL,
    value TEXT NOT NULL,
    value_type VARCHAR(50) DEFAULT 'string',
    shopify_metafield_id VARCHAR(50),
    shopify_owner_id VARCHAR(50),
    shopify_owner_resource VARCHAR(50),
    description TEXT,
    is_visible BOOLEAN DEFAULT true,
    display_order INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT uq_product_metafield UNIQUE (product_id, namespace, key)
);

-- Etilize staging products table
CREATE TABLE IF NOT EXISTS etilize_staging_products (
    id SERIAL PRIMARY KEY,
    batch_id INTEGER NOT NULL REFERENCES etilize_import_batches(id) ON DELETE CASCADE,
    etilize_id VARCHAR(100),
    raw_data JSONB NOT NULL,
    title VARCHAR(1000),
    sku VARCHAR(200),
    manufacturer_part_number VARCHAR(200),
    brand VARCHAR(200),
    manufacturer VARCHAR(200),
    description TEXT,
    price DECIMAL(10,2),
    processing_status VARCHAR(20) DEFAULT 'pending',
    validation_status VARCHAR(20),
    mapping_status VARCHAR(20),
    validation_errors JSONB,
    validation_warnings JSONB,
    mapped_product_id INTEGER REFERENCES products(id),
    mapping_confidence DECIMAL(3,2) CHECK (mapping_confidence >= 0 AND mapping_confidence <= 1),
    mapping_method VARCHAR(50),
    mapping_details JSONB,
    processed_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Product sources table
CREATE TABLE IF NOT EXISTS product_sources (
    id SERIAL PRIMARY KEY,
    product_id INTEGER NOT NULL REFERENCES products(id) ON DELETE CASCADE,
    source_type VARCHAR(50) NOT NULL,
    source_priority INTEGER DEFAULT 0,
    source_identifier VARCHAR(200),
    source_url VARCHAR(1000),
    source_data JSONB,
    last_updated TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    sync_status VARCHAR(20),
    last_synced TIMESTAMPTZ,
    sync_errors JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT uq_product_source UNIQUE (product_id, source_type, source_identifier)
);

-- Product change logs table
CREATE TABLE IF NOT EXISTS product_change_logs (
    id SERIAL PRIMARY KEY,
    product_id INTEGER NOT NULL REFERENCES products(id) ON DELETE CASCADE,
    change_type VARCHAR(50) NOT NULL,
    field_name VARCHAR(100),
    old_value TEXT,
    new_value TEXT,
    value_type VARCHAR(20),
    source_type VARCHAR(50) NOT NULL,
    source_id VARCHAR(100),
    triggered_by INTEGER REFERENCES users(id),
    batch_id INTEGER REFERENCES etilize_import_batches(id),
    job_id INTEGER REFERENCES jobs(id),
    change_reason VARCHAR(200),
    confidence_score DECIMAL(3,2) CHECK (confidence_score >= 0 AND confidence_score <= 1),
    meta_data JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ============================================
-- 3. CREATE INDEXES
-- ============================================

-- Users indexes
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_supabase_id ON users(supabase_id);
CREATE INDEX idx_users_last_login ON users(last_login);

-- Categories indexes
CREATE INDEX idx_categories_slug ON categories(slug);
CREATE INDEX idx_categories_parent_id ON categories(parent_id);
CREATE INDEX idx_categories_level ON categories(level);
CREATE INDEX idx_categories_path ON categories(path);
CREATE INDEX idx_categories_shopify_collection_id ON categories(shopify_collection_id);
CREATE INDEX idx_categories_parent_level ON categories(parent_id, level);

-- Configurations indexes
CREATE INDEX idx_configurations_category ON configurations(category);

-- Sync queue indexes
CREATE INDEX idx_sync_queue_scheduled_at ON sync_queue(scheduled_at);
CREATE INDEX idx_sync_queue_item_type_id ON sync_queue(item_type, item_id);
CREATE INDEX idx_sync_queue_target_system ON sync_queue(target_system);
CREATE INDEX idx_sync_queue_status ON sync_queue(status);
CREATE INDEX idx_sync_queue_priority_status ON sync_queue(priority DESC, status);

-- Icons indexes
CREATE INDEX idx_icons_category_id ON icons(category_id);
CREATE INDEX idx_icons_status ON icons(status);
CREATE INDEX idx_icons_file_hash ON icons(file_hash);
CREATE INDEX idx_icons_shopify_image_id ON icons(shopify_image_id);
CREATE INDEX idx_icons_generation_batch_id ON icons(generation_batch_id);
CREATE INDEX idx_icons_created_by ON icons(created_by);
CREATE INDEX idx_icons_category_status ON icons(category_id, status);

-- Jobs indexes
CREATE INDEX idx_jobs_user_id ON jobs(user_id);
CREATE INDEX idx_jobs_status ON jobs(status);
CREATE INDEX idx_jobs_script_name ON jobs(script_name);
CREATE INDEX idx_jobs_created_at ON jobs(created_at);
CREATE INDEX idx_jobs_user_status ON jobs(user_id, status);

-- Import rules indexes
CREATE INDEX idx_import_rules_rule_type ON import_rules(rule_type);
CREATE INDEX idx_import_rules_rule_category ON import_rules(rule_category);
CREATE INDEX idx_import_rules_is_active ON import_rules(is_active);
CREATE INDEX idx_import_rules_priority ON import_rules(priority);

-- Sync history indexes
CREATE INDEX idx_sync_history_sync_type ON sync_history(sync_type);
CREATE INDEX idx_sync_history_status ON sync_history(status);
CREATE INDEX idx_sync_history_user_id ON sync_history(user_id);
CREATE INDEX idx_sync_history_job_id ON sync_history(job_id);
CREATE INDEX idx_sync_history_started_at ON sync_history(started_at);
CREATE INDEX idx_sync_history_type_status ON sync_history(sync_type, status);

-- System logs indexes
CREATE INDEX idx_system_logs_level ON system_logs(level);
CREATE INDEX idx_system_logs_created_at ON system_logs(created_at);
CREATE INDEX idx_system_logs_user_id ON system_logs(user_id);
CREATE INDEX idx_system_logs_job_id ON system_logs(job_id);
CREATE INDEX idx_system_logs_module ON system_logs(module);
CREATE INDEX idx_system_logs_level_date ON system_logs(level, created_at);

-- Etilize import batches indexes
CREATE INDEX idx_etilize_import_batches_import_type ON etilize_import_batches(import_type);
CREATE INDEX idx_etilize_import_batches_status ON etilize_import_batches(status);
CREATE INDEX idx_etilize_import_batches_triggered_by ON etilize_import_batches(triggered_by);
CREATE INDEX idx_etilize_import_batches_started_at ON etilize_import_batches(started_at);

-- Products indexes
CREATE INDEX idx_products_sku ON products(sku);
CREATE INDEX idx_products_category_id ON products(category_id);
CREATE INDEX idx_products_status ON products(status);
CREATE INDEX idx_products_brand ON products(brand);
CREATE INDEX idx_products_manufacturer_part_number ON products(manufacturer_part_number);
CREATE INDEX idx_products_shopify_product_id ON products(shopify_product_id);
CREATE INDEX idx_products_shopify_id ON products(shopify_id);
CREATE INDEX idx_products_etilize_id ON products(etilize_id);
CREATE INDEX idx_products_import_batch_id ON products(import_batch_id);
CREATE INDEX idx_products_has_conflicts ON products(has_conflicts);
CREATE INDEX idx_products_data_quality_score ON products(data_quality_score);
CREATE INDEX idx_products_category_status ON products(category_id, status);
CREATE INDEX idx_products_brand_category ON products(brand, category_id);

-- Shopify syncs indexes
CREATE INDEX idx_shopify_syncs_mode ON shopify_syncs(mode);
CREATE INDEX idx_shopify_syncs_status ON shopify_syncs(status);
CREATE INDEX idx_shopify_syncs_import_batch_id ON shopify_syncs(import_batch_id);
CREATE INDEX idx_shopify_syncs_triggered_by ON shopify_syncs(triggered_by);
CREATE INDEX idx_shopify_syncs_created_at ON shopify_syncs(created_at);

-- Product images indexes
CREATE INDEX idx_product_images_product_id ON product_images(product_id);
CREATE INDEX idx_product_images_file_hash ON product_images(file_hash);
CREATE INDEX idx_product_images_shopify_image_id ON product_images(shopify_image_id);

-- Product metafields indexes
CREATE INDEX idx_product_metafields_product_id ON product_metafields(product_id);
CREATE INDEX idx_product_metafields_namespace ON product_metafields(namespace);
CREATE INDEX idx_product_metafields_namespace_key ON product_metafields(namespace, key);
CREATE INDEX idx_product_metafields_shopify_metafield_id ON product_metafields(shopify_metafield_id);
CREATE INDEX idx_product_metafields_product_namespace ON product_metafields(product_id, namespace);

-- Etilize staging products indexes
CREATE INDEX idx_etilize_staging_products_batch_id ON etilize_staging_products(batch_id);
CREATE INDEX idx_etilize_staging_products_sku ON etilize_staging_products(sku);
CREATE INDEX idx_etilize_staging_products_etilize_id ON etilize_staging_products(etilize_id);
CREATE INDEX idx_etilize_staging_products_manufacturer_part_number ON etilize_staging_products(manufacturer_part_number);
CREATE INDEX idx_etilize_staging_products_processing_status ON etilize_staging_products(processing_status);
CREATE INDEX idx_etilize_staging_products_validation_status ON etilize_staging_products(validation_status);
CREATE INDEX idx_etilize_staging_products_mapping_status ON etilize_staging_products(mapping_status);

-- Product sources indexes
CREATE INDEX idx_product_sources_product_id ON product_sources(product_id);
CREATE INDEX idx_product_sources_source_type ON product_sources(source_type);
CREATE INDEX idx_product_sources_source_priority ON product_sources(source_priority);
CREATE INDEX idx_product_sources_last_updated ON product_sources(last_updated);

-- Product change logs indexes
CREATE INDEX idx_product_change_logs_product_id ON product_change_logs(product_id);
CREATE INDEX idx_product_change_logs_change_type ON product_change_logs(change_type);
CREATE INDEX idx_product_change_logs_field_name ON product_change_logs(field_name);
CREATE INDEX idx_product_change_logs_source_type ON product_change_logs(source_type);
CREATE INDEX idx_product_change_logs_created_at ON product_change_logs(created_at);
CREATE INDEX idx_product_change_logs_batch_id ON product_change_logs(batch_id);

-- ============================================
-- 4. CREATE TRIGGERS
-- ============================================

-- Updated_at timestamp trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply updated_at triggers to all tables with updated_at column
CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_categories_updated_at BEFORE UPDATE ON categories
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_configurations_updated_at BEFORE UPDATE ON configurations
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_sync_queue_updated_at BEFORE UPDATE ON sync_queue
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_icons_updated_at BEFORE UPDATE ON icons
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_import_rules_updated_at BEFORE UPDATE ON import_rules
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_products_updated_at BEFORE UPDATE ON products
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_product_images_updated_at BEFORE UPDATE ON product_images
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_product_metafields_updated_at BEFORE UPDATE ON product_metafields
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_etilize_staging_products_updated_at BEFORE UPDATE ON etilize_staging_products
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_product_sources_updated_at BEFORE UPDATE ON product_sources
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- 5. ROW LEVEL SECURITY (RLS) POLICIES
-- ============================================

-- Enable RLS on all tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE configurations ENABLE ROW LEVEL SECURITY;
ALTER TABLE sync_queue ENABLE ROW LEVEL SECURITY;
ALTER TABLE icons ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobs ENABLE ROW LEVEL SECURITY;
ALTER TABLE import_rules ENABLE ROW LEVEL SECURITY;
ALTER TABLE sync_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE system_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE etilize_import_batches ENABLE ROW LEVEL SECURITY;
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
ALTER TABLE shopify_syncs ENABLE ROW LEVEL SECURITY;
ALTER TABLE product_images ENABLE ROW LEVEL SECURITY;
ALTER TABLE product_metafields ENABLE ROW LEVEL SECURITY;
ALTER TABLE etilize_staging_products ENABLE ROW LEVEL SECURITY;
ALTER TABLE product_sources ENABLE ROW LEVEL SECURITY;
ALTER TABLE product_change_logs ENABLE ROW LEVEL SECURITY;

-- Basic RLS policies (customize based on your requirements)
-- Allow authenticated users to read their own data
CREATE POLICY "Users can view own profile" ON users
    FOR SELECT USING (auth.uid() = supabase_id);

CREATE POLICY "Users can update own profile" ON users
    FOR UPDATE USING (auth.uid() = supabase_id);

-- Allow authenticated users to read all categories
CREATE POLICY "Authenticated users can view categories" ON categories
    FOR SELECT TO authenticated USING (true);

-- Allow admin users to manage categories
CREATE POLICY "Admins can manage categories" ON categories
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM users
            WHERE users.supabase_id = auth.uid()
            AND users.is_admin = true
        )
    );

-- Similar policies for other tables...

-- ============================================
-- 6. FUNCTIONS AND VIEWS
-- ============================================

-- Function to calculate category path
CREATE OR REPLACE FUNCTION calculate_category_path(category_id INTEGER)
RETURNS VARCHAR AS $$
DECLARE
    path_result VARCHAR;
    current_id INTEGER;
    parent_id INTEGER;
BEGIN
    path_result := category_id::VARCHAR;
    current_id := category_id;
    
    LOOP
        SELECT c.parent_id INTO parent_id
        FROM categories c
        WHERE c.id = current_id;
        
        EXIT WHEN parent_id IS NULL;
        
        path_result := parent_id || '/' || path_result;
        current_id := parent_id;
    END LOOP;
    
    RETURN '/' || path_result || '/';
END;
$$ LANGUAGE plpgsql;

-- View for product inventory status
CREATE OR REPLACE VIEW product_inventory_status AS
SELECT 
    p.id,
    p.sku,
    p.name,
    p.inventory_quantity,
    p.track_inventory,
    p.continue_selling_when_out_of_stock,
    CASE 
        WHEN NOT p.track_inventory THEN 'unlimited'
        WHEN p.inventory_quantity > 10 THEN 'in_stock'
        WHEN p.inventory_quantity > 0 THEN 'low_stock'
        WHEN p.continue_selling_when_out_of_stock THEN 'out_of_stock_continue'
        ELSE 'out_of_stock'
    END AS stock_status
FROM products p;

-- View for sync queue status summary
CREATE OR REPLACE VIEW sync_queue_summary AS
SELECT 
    target_system,
    status,
    COUNT(*) as count,
    MIN(scheduled_at) as next_scheduled,
    MAX(updated_at) as last_updated
FROM sync_queue
GROUP BY target_system, status;

-- ============================================
-- 7. COMMENTS
-- ============================================

COMMENT ON TABLE users IS 'System users with Supabase auth integration';
COMMENT ON TABLE categories IS 'Product categories with hierarchical structure';
COMMENT ON TABLE products IS 'Product catalog with multi-source data integration';
COMMENT ON TABLE sync_queue IS 'Queue for synchronization operations';
COMMENT ON TABLE icons IS 'AI-generated category icons';
COMMENT ON TABLE jobs IS 'Background job tracking';
COMMENT ON TABLE sync_history IS 'Historical record of all synchronization operations';
COMMENT ON TABLE system_logs IS 'Application-level logging';

-- ============================================
-- 8. GRANTS (for Supabase service role)
-- ============================================

-- Grant necessary permissions to authenticated users
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO authenticated;
GRANT INSERT, UPDATE ON users, sync_history, system_logs TO authenticated;

-- Grant full access to service role
GRANT ALL ON ALL TABLES IN SCHEMA public TO service_role;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO service_role;
GRANT ALL ON ALL FUNCTIONS IN SCHEMA public TO service_role;